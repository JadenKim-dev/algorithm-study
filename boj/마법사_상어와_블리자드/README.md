### 사용한 알고리즘/자료구조

문제에서 제시한 조건을 구현하는 시뮬레이션 문제이다.  
각 칸에 존재하는 구슬의 종류를 2차원 배열로 저장하는 board를 사용했다.

blizzard(d, s)는 d 방향으로 s 크기만큼의 블리자드를 사용하여 구슬을 제거하는 메서드이다.  
구슬을 제거한 곳에 EMPTY = 0을 저장한다.

explode()는 4개 이상 인접한 구슬을 폭파시키는 메서드이다.  
이 과정에서 itertools의 groupby 메서드를 사용했다.  
nums = [board[r][c] for r, c in routes if board[r][c]]를 통해 nums에는 0인 칸을 제외하고 칸의 순서대로 구슬의 종류를 저장하게 한다.  
그 다음 groupby(nums)를 하게 되면 (구슬의 종류, 해당 종류의 구슬들) 형태로 데이터들이 변환된다.  
groupby는 연속하지 않은 데이터들은 서로 다른 그룹으로 분류하기 때문에 결과는 다음과 같이 계산된다.

```
[1, 1, 2, 1, 3, 3, 4, 4, 4] -> [1, 1], [2, 1], [1, 1], [3, 2], [4, 3]
```

폭파되는 구슬이 없을 때까지 과정을 반복하고, 남은 구슬의 형태를 groupby의 결과와 같은 형식으로 반환한다.

transform_from(gems)는 gems를 이용하여 board에 구슬을 채워넣는 메서드이다.  
이 때 gems는 explode()의 반환값으로 얻어진 배열로, 문제에서 요구하는 조건에 맞추기 용이한 형태로 되어있다.  
이 메서드에서는 itertools의 chain. from_iterable()을 사용했다.  
해당 메서드는 하나의 서열로 해당 iterable 객체를 변환한다.

```
[[1, 1], [2, 2], [3, 3]] -> [1, 1, 2, 2, 3, 3]
```
